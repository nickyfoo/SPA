#include <string>
#include <vector>

#include "ast.h"
#include "catch.hpp"

class StubNode : public Node {
 private:
  NodeType kind_;

 public:
  StubNode(NodeType kind) : Node(LocInfo{.line_no = rand(), .col_no = rand()}) {
    this->kind_ = kind;
  }
  NodeType kind() { return this->kind_; }
};

TEST_CASE("Test Identifier Node") {
  IdentifierNode *i;
  int ln, cn;
  std::string name;

  ln = rand();
  cn = rand();
  name = "X";
  i = new IdentifierNode(name, LocInfo{.line_no = ln, .col_no = cn});
  REQUIRE(i->kind() == NodeType::Identifier);
  REQUIRE(i->line_no() == ln);
  REQUIRE(i->col_no() == cn);
  REQUIRE(i->name() == name);

  ln = rand();
  cn = rand();
  name = "Foo";
  i = new IdentifierNode(name, LocInfo{.line_no = ln, .col_no = cn});
  REQUIRE(i->kind() == NodeType::Identifier);
  REQUIRE(i->line_no() == ln);
  REQUIRE(i->col_no() == cn);
  REQUIRE(i->name() == name);
}

TEST_CASE("Test Constant Node") {
  ConstantNode *c;
  int ln, cn;
  std::string value;

  ln = rand();
  cn = rand();
  value = "12345";
  c = new ConstantNode(value, LocInfo{.line_no = ln, .col_no = cn});
  REQUIRE(c->kind() == NodeType::Constant);
  REQUIRE(c->line_no() == ln);
  REQUIRE(c->col_no() == cn);
  REQUIRE(c->value() == value);

  ln = rand();
  cn = rand();
  value = "652434141";
  c = new ConstantNode(value, LocInfo{.line_no = ln, .col_no = cn});
  REQUIRE(c->kind() == NodeType::Constant);
  REQUIRE(c->line_no() == ln);
  REQUIRE(c->col_no() == cn);
  REQUIRE(c->value() == value);
}

TEST_CASE("Test Expression Node") {
  ExpressionNode *e;
  int ln, cn;
  ExprOp op;
  Node *left, *right;
  std::string expr_string;

  std::vector<std::tuple<ExprOp, Node *, Node *, std::string>> perms{
      {ExprOp::Plus, new StubNode(NodeType::Constant), new StubNode(NodeType::Constant), "1 2 +"},
      {ExprOp::Minus, new StubNode(NodeType::Identifier), new StubNode(NodeType::Identifier),
       "X Y -"},
      {ExprOp::Times, new StubNode(NodeType::Identifier), new StubNode(NodeType::Constant),
       "X 1 *"},
      {ExprOp::Divide, new StubNode(NodeType::Identifier), new StubNode(NodeType::Constant),
       "Y 2 /"},
      {ExprOp::Modulo, new StubNode(NodeType::Identifier), new StubNode(NodeType::Constant),
       "Y 2 %"},
  };

  for (auto p : perms) {
    ln = rand();
    cn = rand();
    op = std::get<0>(p);
    left = std::get<1>(p);
    right = std::get<2>(p);
    expr_string = std::get<3>(p);

    e = new ExpressionNode(op, left, right, expr_string, LocInfo{.line_no = ln, .col_no = cn});

    REQUIRE(e->kind() == NodeType::Expression);
    REQUIRE(e->line_no() == ln);
    REQUIRE(e->col_no() == cn);
    REQUIRE(e->op() == op);
    REQUIRE(e->left() == left);
    REQUIRE(e->right() == right);
    REQUIRE(e->expr_string() == expr_string);
  }

  std::vector<std::tuple<ExprOp, Node *, Node *, std::string>> fail_perms{
      {ExprOp::Plus, nullptr, new StubNode(NodeType::Constant), "1 2 +"},
      {ExprOp::Minus, new StubNode(NodeType::Identifier), nullptr, "X Y -"},
      {ExprOp::Times, new StubNode(NodeType::RelExpression), new StubNode(NodeType::Constant),
       "X 1 *"},
      {ExprOp::Divide, new StubNode(NodeType::Identifier), new StubNode(NodeType::CondExpression),
       "Y 2 /"},
      {ExprOp::Modulo, new StubNode(NodeType::Assign), new StubNode(NodeType::Constant), "Y 2 %"},
      {ExprOp::Plus, new StubNode(NodeType::If), new StubNode(NodeType::Constant), "1 2 +"},
      {ExprOp::Minus, new StubNode(NodeType::Identifier), new StubNode(NodeType::While), "X Y -"},
      {ExprOp::Times, new StubNode(NodeType::Read), new StubNode(NodeType::Constant), "X 1 *"},
      {ExprOp::Divide, new StubNode(NodeType::Identifier), new StubNode(NodeType::Call), "Y 2 /"},
      {ExprOp::Modulo, new StubNode(NodeType::Assign), new StubNode(NodeType::Constant), "Y 2 %"},
      {ExprOp::Divide, new StubNode(NodeType::Identifier), new StubNode(NodeType::Procedure),
       "Y 2 /"},
      {ExprOp::Modulo, new StubNode(NodeType::Program), new StubNode(NodeType::Constant), "Y 2 %"},
  };

  for (auto p : fail_perms) {
    ln = rand();
    cn = rand();
    op = std::get<0>(p);
    left = std::get<1>(p);
    right = std::get<2>(p);
    expr_string = std::get<3>(p);
    REQUIRE_THROWS_AS(
        ExpressionNode(op, left, right, expr_string, LocInfo{.line_no = ln, .col_no = cn}),
        std::invalid_argument);
  }
}

TEST_CASE("Test RelExpression Node") {
  RelExpressionNode *r;
  int ln, cn;
  RelExprOp op;
  Node *left, *right;

  std::vector<std::tuple<RelExprOp, Node *, Node *>> perms{
      {RelExprOp::Gt, new StubNode(NodeType::Constant), new StubNode(NodeType::Constant)},
      {RelExprOp::Gte, new StubNode(NodeType::Identifier), new StubNode(NodeType::Identifier)},
      {RelExprOp::Lt, new StubNode(NodeType::Identifier), new StubNode(NodeType::Constant)},
      {RelExprOp::Lte, new StubNode(NodeType::Identifier), new StubNode(NodeType::Constant)},
      {RelExprOp::Eq, new StubNode(NodeType::Identifier), new StubNode(NodeType::Constant)},
      {RelExprOp::Neq, new StubNode(NodeType::Identifier), new StubNode(NodeType::Constant)},
  };

  for (auto p : perms) {
    ln = rand();
    cn = rand();
    op = std::get<0>(p);
    left = std::get<1>(p);
    right = std::get<2>(p);

    r = new RelExpressionNode(op, left, right, LocInfo{.line_no = ln, .col_no = cn});

    REQUIRE(r->kind() == NodeType::RelExpression);
    REQUIRE(r->line_no() == ln);
    REQUIRE(r->col_no() == cn);
    REQUIRE(r->op() == op);
    REQUIRE(r->left() == left);
    REQUIRE(r->right() == right);
  }

  std::vector<std::tuple<RelExprOp, Node *, Node *>> fail_perms{
      {RelExprOp::Lte, nullptr, new StubNode(NodeType::Constant)},
      {RelExprOp::Gt, new StubNode(NodeType::Identifier), nullptr},
      {RelExprOp::Eq, new StubNode(NodeType::RelExpression), new StubNode(NodeType::Constant)},
      {RelExprOp::Neq, new StubNode(NodeType::Identifier), new StubNode(NodeType::CondExpression)},
      {RelExprOp::Gte, new StubNode(NodeType::Assign), new StubNode(NodeType::Constant)},
      {RelExprOp::Gt, new StubNode(NodeType::If), new StubNode(NodeType::Constant)},
      {RelExprOp::Lte, new StubNode(NodeType::Identifier), new StubNode(NodeType::While)},
      {RelExprOp::Eq, new StubNode(NodeType::Read), new StubNode(NodeType::Constant)},
      {RelExprOp::Lt, new StubNode(NodeType::Identifier), new StubNode(NodeType::Call)},
      {RelExprOp::Neq, new StubNode(NodeType::Assign), new StubNode(NodeType::Constant)},
      {RelExprOp::Gt, new StubNode(NodeType::Identifier), new StubNode(NodeType::Procedure)},
      {RelExprOp::Gte, new StubNode(NodeType::Program), new StubNode(NodeType::Constant)},
  };

  for (auto p : fail_perms) {
    ln = rand();
    cn = rand();
    op = std::get<0>(p);
    left = std::get<1>(p);
    right = std::get<2>(p);
    REQUIRE_THROWS_AS(RelExpressionNode(op, left, right, LocInfo{.line_no = ln, .col_no = cn}),
                      std::invalid_argument);
  }
}

TEST_CASE("Test CondExpression Node") {
  CondExpressionNode *c;
  int ln, cn;
  CondExprOp op;
  Node *left, *right;

  std::vector<std::tuple<CondExprOp, Node *, Node *>> perms{
      {CondExprOp::And, new StubNode(NodeType::CondExpression),
       new StubNode(NodeType::CondExpression)},
      {CondExprOp::Or, new StubNode(NodeType::RelExpression),
       new StubNode(NodeType::RelExpression)},
      {CondExprOp::Not, new StubNode(NodeType::CondExpression), nullptr)},
      {CondExprOp::And, new StubNode(NodeType::RelExpression),
       new StubNode(NodeType::CondExpression)},
      {CondExprOp::Or, new StubNode(NodeType::CondExpression), nullptr},
      {CondExprOp::Not, new StubNode(NodeType::RelExpression), nullptr},
  };

  for (auto p : perms) {
    ln = rand();
    cn = rand();
    op = std::get<0>(p);
    left = std::get<1>(p);
    right = std::get<2>(p);

    c = new CondExpressionNode(op, left, right, LocInfo{.line_no = ln, .col_no = cn});

    REQUIRE(c->kind() == NodeType::CondExpression);
    REQUIRE(c->line_no() == ln);
    REQUIRE(c->col_no() == cn);
    REQUIRE(c->op() == op);
    REQUIRE(c->left() == left);
    REQUIRE(c->right() == right);
  }

  std::vector<std::tuple<RelExprOp, Node *, Node *>> fail_perms{
      {RelExprOp::Lte, nullptr, new StubNode(NodeType::Constant)},
      {RelExprOp::Gt, new StubNode(NodeType::Identifier), nullptr},
      {RelExprOp::Eq, new StubNode(NodeType::RelExpression), new StubNode(NodeType::Constant)},
      {RelExprOp::Neq, new StubNode(NodeType::Identifier), new StubNode(NodeType::CondExpression)},
      {RelExprOp::Gte, new StubNode(NodeType::Assign), new StubNode(NodeType::Constant)},
      {RelExprOp::Gt, new StubNode(NodeType::If), new StubNode(NodeType::Constant)},
      {RelExprOp::Lte, new StubNode(NodeType::Identifier), new StubNode(NodeType::While)},
      {RelExprOp::Eq, new StubNode(NodeType::Read), new StubNode(NodeType::Constant)},
      {RelExprOp::Lt, new StubNode(NodeType::Identifier), new StubNode(NodeType::Call)},
      {RelExprOp::Neq, new StubNode(NodeType::Assign), new StubNode(NodeType::Constant)},
      {RelExprOp::Gt, new StubNode(NodeType::Identifier), new StubNode(NodeType::Procedure)},
      {RelExprOp::Gte, new StubNode(NodeType::Program), new StubNode(NodeType::Constant)},
  };

  for (auto p : fail_perms) {
    ln = rand();
    cn = rand();
    op = std::get<0>(p);
    left = std::get<1>(p);
    right = std::get<2>(p);
    REQUIRE_THROWS_AS(RelExpressionNode(op, left, right, LocInfo{.line_no = ln, .col_no = cn}),
                      std::invalid_argument);
  }
}
